package org.example.multithreading.alishev.semaphore;

import java.util.concurrent.Semaphore;

public class TestSemaphore {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3); //аргумент - количество разрешений (permits) для потоков. Например, сколько потоков одновременно могут отправлять данные на этот сервер.
        //потоки могут забирать разрешения себе и взаимодействовать с ресурсом, но после того, как они закончили взаимодействовать с ресурсом, они это разрешение отдают обратно. И уже другой поток может взять это разрешение и сам взаимодействовать с ресурсом.
        try {
            semaphore.acquire(); //этот метод "выдает" одно из наших трех разрешений, когда поток начинает взаимодействие с ресурсом.
            semaphore.acquire();
            semaphore.acquire();

            System.out.println("Все разрешения истрачены!");

            semaphore.acquire(); //Если потоков, например, четыре, то четвертый поток при вызове acquire() останется на этом вызове, будет ждать, пока не освободится одно из разрешений. Здесь для примера просто вызываем 4 раза этот метод в main, а не в разных потоках.

            System.out.println("Невозможно попасть сюда..."); //это сообщение выведено не будет, так как все разрешения истрачены и поток ждет на 4ом вызове acquire(). Чтобы исполнение пошло дальше, необходимо, чтобы какой-то из потоков вызвал метод release() на том же объекте семафора.
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        semaphore.release(); //метод отпускает разрешение после того, как поток закончил работу с ресурсом. Но в данном примере выполнение кода до этой строки не дойдет.

        System.out.println(semaphore.availablePermits()); // возвращает количество свободных разрешений.
    }
}
